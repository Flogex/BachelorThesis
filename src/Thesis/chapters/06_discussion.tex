% !TeX root = ../main.tex
\chapter{Diskussion}\label{ch:discussion}

In diesem Kapitel werden die Ergebnisse aus \cref{ch:comparison} ausgewertet und diskutiert. Dazu werden vor allem die Auswirkungen von Introspection und Microtypes auf die Performance, Evolvierbarkeit und Komplexität einer Introspected-REST-API beleuchtet.

\section{Performance}\label{sec:discussion|performance}

Die Null-Hypothese des Experiments lautete: \enquote{Die ermittelte Performance der API ist bei allen vier untersuchten API-Stilen gleich}. Diese Aussage wurde durch die Messergebnisse falsifiziert, da signifikante Unterschiede der Antwortzeiten festgestellt wurden. Generell kann eine starke Korrelation zwischen der Gesamtgröße ausgetauschter Nachrichten und der Antwortzeit festgestellt werden (durchschnittlicher Korrelationsfaktor \(\text{corr}(\mathit{Len}_{\mathit{Req}} + \mathit{Len}_{\mathit{Resp}}, RT) = 0,93\)). Dies war nach \eqref{eqn:comp-criteria|performance|response-time} und \eqref{eqn:comp-criteria|performance|message-transmission-time} zu erwarten, da Latenz und maximale Datenübertragungsrate während des Experiments konstant gehalten wurden.

GraphQL bietet eine exakte Auswahl der Daten und vermeidet so Over- und Underfetching; gRPC setzt mit Protobuf ein effizientes Datenübertragungsformat ein und das ganze Protokoll ist auf eine hohe Performance ausgerichtet \autocite{gRPC_About}. Introspected REST und REST können hingegen nicht mit derartigen Performancefeatures aufwarten. Stattdessen werden mit jedem Response zusätzliche Metadaten gesendet, sodass sich z.B.\ bei Aufgabe~\ref{itm:data-collection|performance|tasks|all-notes} die Größe des Introspected-REST- und des GraphQL-Response um zwei Größenordnungen unterscheiden. Da die Unterschiede sehr groß ausfallen, stellt sich die Frage, ob GraphQL durch die Auswahl der Aufgaben bevorzugt wurde. Tatsächlich führen Aufgaben~\ref{itm:data-collection|performance|tasks|all-notes} und~\ref{itm:data-collection|performance|tasks|related-keywords} zu einem \emph{N+1-Problem} genannten Muster, da für alle \(n\) Elemente einer Liste ein oder mehrere zusätzliche Requests gesendet werden müssen, während bei GraphQL alle Informationen in einem Response enthalten sind. Diese Tatsache spricht aber nicht gegen das durchgeführte Experiment, da dies auf die Eigenheiten der API-Stile zurückzuführen sind und ein derartiges Szenario auch in der Realität auftreten kann.

Dass alle Requests innerhalb eines Threads von JMeter sequentiell ausgeführt werden, scheint auf Kosten der API-Stile, die viele Requests benötigen, zu gehen. Beispielsweise könnten bei Aufgabe~\ref{itm:data-collection|performance|tasks|all-notes} alle Notizen durch den Introspected-REST-Client parallel geladen werden. Gerade das Multiplexing in HTTP/2 könnte einen großen Beitrag dazu leisten, die Antwortzeiten von Introspected REST und REST an die von GraphQL anzunähern. Eine solche Untersuchung wurde in der vorliegenden Arbeit aber nicht durchgeführt. Andererseits ist auffällig, dass Introspected REST eine ähnliche Performance wie REST aufweist, obwohl mehr Requests gesendet wurden.

Da ungefähr die gleiche Anzahl an Bytes bei Introspected REST und REST ausgetauscht werden, weisen auch die Antwortzeiten ähnlich hohe Werte auf. Ein von Vasilakis identifiziertes Problem von REST war die niedrige Performance (Problem~\ref{itm:intrest|theory|rest-problems|performance-sacrifice}). Für einen hypermediaaffinen Client führt Introspected REST aber zu keiner Verbesserung. Ein anderes Bild würde sich wahrscheinlich ergeben, wenn die Betrachtung für einen Client, der kein Hypermedia verwendet, durchgeführt werden würde. Beispielsweise könnten so bei Aufgabe~\ref{itm:data-collection|performance|tasks|all-notes} \(2419\) gesendete und \(7956\) empfangene Bytes eingespart werden. In diesem Experiment wurde nicht untersucht, ob eine exaktere Auswahl der Daten, welche der Server zurücksenden soll, durch Microtypes die Performance beeinflusst. Aspekte sind hierbei, dass eventuell nutzlose Daten nicht zum Client gesendet werden, andererseits aber die Cachebarkeit der Responses verringert wird. Es haben weiterhin Server-Metriken wie der Durchsatz keine Berücksichtigung gefunden. Auch wurde die vom Client wahrgenommene Performance nicht berücksichtigt: Werden nämlich viele kleine Requests gesendet, kann der Client schon die Daten aus den ersten erhaltenen Responses anzeigen, während er noch auf andere wartet. So scheint der Client die Arbeit schon verrichtet zu haben, obwohl diese noch nicht vollständig abgeschlossen ist. 

\section{Evolvierbarkeit}\label{sec:discussion|evolvability}

REST ist ein API-Stil, welcher auf Langlebigkeit ausgelegt ist \autocite[S.~41]{Block2014}, und Introspected REST erbt diese Eigenschaft. Von den beiden Grundpfeilern von Introspected REST, dem Introspection-Prinzip und Microtypes, wurde angenommen, dass vor allem Microtypes die Chance eröffnen, die Evolvierbarkeit einer API positiv zu beeinflussen, denn das Introspection-Prinzip verändert nur den Ort der Hypermedia-Elemente. Introspection verbessert die Evolvierbarkeit dahingehend, dass Hypermedia zu einer bestehenden API hinzugefügt werden kann, ohne den für die Nutzdaten verwendeten Mediatype oder bestehende Clients anpassen zu müssen. Bei der NeverNote-API wurde Hypermedia allerdings von Beginn an verwendet.

Bei dem Vergleich in \cref{sec:comparison|evolvability} unterscheiden sich Introspected REST und REST nur bei Änderung~\ref{itm:data-collection|evolvability|new-capability}. Tatsächlich dienen Microtypes auch eher dazu, Details der Kommunikation wie das Datenaustauschformat zu verhandeln oder bestimmte Funktionalität anzufordern, und beschreiben die Semantik ihrer eigenen, kleinen Schnittstelle \autocite{Vasilakis2017a}. Microtypes erhöhen die Austauschbarkeit der Funktionalität auf Clientseite, da sie abgeschlossene, zusammensetzbare Teile eines Ganzen (Holons) sind. Zum Beispiel können \emph{HAL-FORMS}\footnote{The HAL-FORMS Media Type: \url{https://rwcbook.github.io/hal-forms} (besucht am 14.09.2020)} durch \emph{JSONForms}\footnote{JSONForms: \url{https://jsonforms.io/} (besucht am 14.09.2020)} ohne Auswirkungen auf andere Microtypes ersetzt werden. Doch bietet ein Server einen Microtype einmal an, gehört dieser zur öffentlichen Schnittstelle der API und unterliegt den gleichen Einflüssen hinsichtlich der Evolvierbarkeit wie jeder andere Teil der Schnittstelle. Tatsächlich wird durch die Unterstützung vieler Microtypes die API-Oberfläche größer, sodass insgesamt sogar mehr abwärtsinkompatible Änderungen auftreten könnten. Abwärtsinkompatible Änderungen würden eine neue Version eines Microtypes nach sich ziehen, sodass bestehende Clients nicht in den Genuss der Änderungen kommen. Microtypes verbessern also die Evolvierbarkeit der NeverNote-API nur in geringem Maße. Sie erhöhen die Austauschbarkeit für Clients, aber nicht die Änderbarkeit.

\para{}Introspected REST und REST erreichen Evolvierbarkeit vor allem durch eine lose Kopplung von Client und Server. Genauer gesagt wird Businesslogik nicht im Client dupliziert. So können Änderungen erfolgen, ohne dass viele Clients angepasst werden müssen. Stattdessen adoptieren sie die Änderungen automatisch, sobald der Server die geänderten Informationen bereitstellt \autocite[37:35--38:47]{Drotbohm2019}. Dadurch wird erreicht, dass bspw.\ bei Änderung~\ref{itm:data-collection|evolvability|constrain-publish-step} keine Anpassung der Introspected-REST- und REST-Clients erforderlich ist, während dies bei GraphQL und gRPC der Fall ist. Im Vergleich zu gRPC stellen Introspected REST, REST und GraphQL eine Möglichkeit bereit, Informationen über die API durch Hypermedia und/oder Introspection zur Laufzeit abzufragen. Clients können automatisch angepasst werden, indem sie die Laufzeitinformationen verarbeiten, anstatt auf zur Übersetzungszeit kodierte Informationen zu vertrauen. gRPC-Clients verfügen bspw.\ nur über das Wissen aus einer vorher festgesetzten Servicedefinition und können dieses nicht aktualisieren. Eine automatische Anpassung des Clients, bspw.\ bei Änderung~\ref{itm:data-collection|evolvability|add-mandatory-form-field}, ist somit nicht möglich.

\section{Komplexität}\label{sec:discussion|complexity}

Wie in \cref{subsec:comp-criteria|complexity|evaluation} beschrieben, wurde bewusst auf eine Gewichtung der Heuristiken verzichtet, sodass von einer abschließenden Bewertung durch Addition der einzelnen Ergebnisse abzusehen ist. Weiterhin sei noch einmal betont, dass es sich nur um Heuristiken handelt und die Auflistung unvollständig ist. Andere Heuristiken könnten bspw.\ bestimmen, wie schnell die API einer Cliententwicklerin oder einem Cliententwickler Feedback geben kann oder ob Abkürzungen für Power-Userinnen und -User eingeführt werden können, um die Effizienz oft verwendeter Aktionen zu steigern, 

Introspection verbessert die Benutzbarkeit der Introspected-REST-API vor allem für Clients, welche nicht an Hypermedia interessiert sind. Diesen bleiben unnötige Informationen erspart. Auch Microtypes führen dazu, dass exakter ausgewählt werden kann, welche Informationen ein Client vom Server bekommen will. So kann er sich z.B.\ zwischen verschiedenen Introspection-Microtypes entscheiden, während solch fortgeschrittene Content-Negotiation bei REST-APIs nicht üblich ist. Würde die Utopie eines Microtype-Ökosystems (siehe \cref{subsec:intrest|theory|microtypes}) Realität werden, würden Microtypes auch erheblich zur Konsistenz zwischen APIs verschiedener Anbieter beitragen. Es wäre wohl der Traum einiger App-Entwicklerinnen und -Entwickler, wenn mehrere soziale Netzwerke über eine strukturell gleiche API verfügen würden und man den gleichen Client wiederverwenden könnte, bestenfalls sogar nur die Einstiegs-URL anpassen müsste. Ein weiterer positiver Aspekt der Microtypes ist die Modularität, wodurch theoretisch Softwaremodule für einzelne Microtypes für Server und Client bereitgestellt und durch die Wiederverwendung die Programmierung erleichtert werden könnte.

Einen Einfluss auf die Benutzbarkeit einer Introspected-REST-API konnte der Autor auch durch die Trennung von Nutzdaten und Hypermedia feststellen, da die beiden Responses für die Verwendung einiger Hypermediaelemente wie etwa URI-Templates (\autocite{RFC6570}) zusammengesetzt werden mussten. Gefühlt war durch die Aufspaltung in zwei separate Responses mehr Arbeit nötig. Ein weiterer Punkt ist die gefühlte Komplexitätssteigerung durch die fortgeschrittene Content-Negotiation bei Introspected REST. Anstatt eines einzelnen Mediatypes, welcher während der Nutzung der API meist konstant bleibt, müssen nun im \header{Accept}-Header viele Parameter zur Auswahl der Microtypes angegeben werden.

Alle untersuchten API-Stile haben ihre Eigenheiten, wobei manche der API zum Vorteil, andere zum Nachteil gereichen. Für individuelle Entwicklerinnen und Entwickler ist das Hauptargument wahrscheinlich die Vertrautheit mit dem jeweiligen API-Stil. Würde eine Programmiererin oder ein Programmierer heute mit einer Introspected-REST-API konfrontiert werden, könnte sie oder er die API wahrscheinlich grundlegend verwenden, da sie auf HTTP und REST aufbaut. Doch bis sie sich an Introspection gewöhnt haben, bedürfte es wohl einer Eingewöhnungsphase.

\section{Zusammenfassung}

Die beiden Grundpfeiler von Introspected REST, das Introspection-Prinzip und Microtypes, wirken sich vor allem auf die Performance und Komplexität/Benutzbarkeit einer API aus. Durch die Trennung von Nutz- und Metadaten werden bei einem hypermediaaffinen Client für jeden REST-Request zwei Introspected-REST-Requests benötigt. Dies erhöht die Anzahl gesendeter Bytes, doch verhalten sich die Performanceergebnisse weiterhin ähnlich zu denen der REST-API. Die Auswirkungen von Introspection auf die Benutzbarkeit sind zwiespältig. Einerseits ermöglichen sie es einem Client, sich auf die Nutzdaten bzw.\ die Metadaten zu fokussieren und letztere ggf.\ zu ignorieren. Andererseits erhöht die Trennung die kognitive Belastung. Microtypes ermöglichen einem Client, genauer auszuwählen, welche Daten der Server zurückschicken soll, und Erwartungen an diese Daten zu formulieren. Sie eröffnen ebenfalls die Möglichkeit, die Konsistenz innerhalb einer API und zwischen APIs sicherzustellen. Die Evolvierbarkeit wird durch Introspection für eine API erhöht, die zuvor ohne Hypermedia auskommen musste. Microtypes erhöhen nur die Austauschbarkeit von Funktionalität der API, aber nicht deren Änderbarkeit.