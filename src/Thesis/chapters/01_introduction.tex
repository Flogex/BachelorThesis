% !TeX root = ../main.tex
\chapter{Einleitung}

Es ist Bewegung im Web-API-Bereich. Im Jahr 2000 machte sich REST auf, die zu dieser Zeit verbreiteten SOAP-APIs abzulösen. Infolgedessen verstanden und nutzten Entwicklerinnen und Entwickler zwar das HTTP-Protokoll besser, doch vernachlässigten viele dabei einen wichtigen Bestandteil von REST: das Hypermedia-Prinzip. Roy Fielding, welcher REST zuerst beschrieben hat, sah sich deshalb dazu veranlasst, in einem Blogpost\footnote{R. T. Fielding. (20. Okt. 2008). \enquote{REST APIs must be hypertext-driven,} \textsc{url}: \url{https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven} (besucht am 09.09.2020).} darauf hinzuweisen, dass der Einsatz von Hypermedia für REST-APIs obligatorisch ist. Doch auch danach sah man nur wenige sogenannte \textit{Level-3}-REST-APIs \autocite{Richardson2008} oder aber Clients wurden nicht unter Beachtung des Hypermedia-Prinzips entwickelt. Als Facebook im Jahr 2015 GraphQL der Öffentlichkeit präsentierte, sprangen viele Entwicklerinnen und Entwickler schnell auf diesen neuen API-Stil auf und sagten sich von REST los, was in Überschriften wie \textit{GraphQL is the better REST}\footnote{T. Suchanek. \enquote{GraphQL is the better REST,} \textsc{url}: \url{https://www.howtographql.com/basics/1-graphql-is-the-better-rest/} (besucht am 09.09.2020).} und \textit{REST is the new SOAP}\footnote{P. de Bonchamp. (15. Dez. 2017). \enquote{REST is the new SOAP,} \textsc{url}: \url{https://www.freecodecamp.org/news/rest-is-the-new-soap-97ff6c09896d/} (besucht am 09.09.2020).} mündete. Sie schienen enttäuscht zu sein von dem (semantisch diffusen \autocite{Fowler2006}) Begriff \enquote{REST} und eifrig, eine neue Technologie auf den \textit{Gipfel der überzogenen Erwartungen} \autocite{HypeCycle} zu heben. Im gleichen Jahr wurde mit gRPC ein weiter API-Stil vorgestellt und die Auswahl für API-Anbieter noch vergrößert. Die Frage, wie Web-APIs am besten umgesetzt werden sollen, wird also immer noch diskutiert und das Ende der Geschichte ist noch längst nicht erreicht.

2017 ging die Geschichte weiter, als Filippos Vasilakis Introspected REST vorstellte. Er präsentierte diesen neuen Ansatz für Web-APIs als Alternative sowohl zu REST als auch zu GraphQL. Doch stellt Introspected REST wirklich eine praktikable Alternative zu den heutzutage verbreiteten API-Stilen dar? Welche Vorteile bietet Introspected REST und was kann man daraus lernen? Und sollte ich, als Anbieter einer API, noch heute auf Introspected REST umsteigen? Diese Fragen wurden bisher nirgendwo untersucht, geschweige denn beantwortet. In der vorliegenden Arbeit wird deshalb ein Vergleich von Introspected REST und den oft verwendeten API-Stilen REST, GraphQL und gRPC angestellt. Das Ziel der Arbeit ist, die aufgeworfenen Fragen in einem begrenzten Rahmen zu beantworten.

\para{}Der Hauptteil dieser Arbeit beginnt mit einer Einführung in das Gebiet der Web-APIs. Dazu werden die drei API-Stile vorgestellt, welche neben Introspected REST als Vergleichsobjekte herhalten: REST, GraphQL und gRPC. Die Erläuterungen zu REST bilden gleichzeitig eine wichtige Grundlage für das Verständnis von Introspected REST. Dieser neue API-Stil, welcher auf REST aufbaut, wird in \cref{ch:intrest} beschrieben. Der Fokus liegt dabei auf dessen beiden Grundpfeilern: Dem Introspection-Prinzip und Microtypes. Das Introspection-Prinzip beschränkt die Art und Weise, wie Hypermedia zum Client gelangen darf. Es besagt, dass Nutzdaten und Metadaten getrennt werden sollen. Microtypes sind kleine, abgeschlossene Einheiten, welche eine Funktionalität der API beschreiben. Zusammen übernehmen mehrere Microtypes die Aufgabe von Mediatypes in REST; Mediatypes werden in Introspected REST also in Microtypes zerlegt. Im Rahmen des Vergleichs wurde auch ein Prototyp einer Introspected-REST-API entworfen. Details dazu werden ebenfalls in diesem Kapitel ausgeführt.

Vasilakis hat einige Probleme des REST-Stils identifiziert, auf welche in \cref{subsec:intrest|theory|rest-problems} genauer eingegangen wird. Die genannten Probleme beeinflussen die Faktoren Performance, Evolvierbarkeit und Komplexität. Deshalb werden die API-Stile nach ebendiesen drei Kriterien verglichen. In \cref{ch:comp-criteria} werden die drei Kriterien definiert und Methoden für die Bewertung der API-Stile betrachtet. Für den Vergleich der Performance wird ein Experiment durchgeführt, in welchem API-Clients Aufgaben eines Szenarios bearbeiten müssen. Währenddessen wird die Zeit, welche für die Bearbeitung der Aufgabe benötigt wird, gemessen. Die Evolvierbarkeit wird mithilfe einer ähnlichen Methode bewertet. Es werden Änderungen an einer bestehende API beschrieben. Für jeden API-Stil wird untersucht, welche Anpassungen am Client eine solche Änderung nach sich zieht. Der Vergleich der Komplexität erfolgt durch eine Heuristische Evaluation. Dafür werden Heuristiken für die Benutzbarkeit von APIs sowie allgemeine Usability-Prinzipien aufgegriffen und auf die API-Stile angewendet.

Die Ergebnisse der Vergleiche werden in \cref{ch:comparison} dargelegt. Im Anschluss werden in \cref{ch:discussion} die Ergebnisse ausgewertet und begründet. Vor allem interessiert hier, wie sich das Introspection-Prinzip und Microtypes auf Performance, Evolvierbarkeit und Komplexität auswirken. \Cref{ch:conclusion} bildet den Abschluss der Arbeit. Hier werden die eingangs gestellten Fragen wieder aufgegriffen und anhand der Ergebnisse der Vergleiche teilweise beantwortet. Zum Schluss werden Fragen aufgeworfen, welche durch diese Arbeit noch offengeblieben oder neu hinzugekommen sind.

\para{}Messdaten, Quellcode und sonstige Dateien sind auf dem beiliegendem Datenträger sowie im Repository zur Arbeit\footnote{BachelorThesis (Repository): \url{https://github.com/Flogex/BachelorThesis}} zu finden.