\section{Introduction}\label{sec:introduction}

In 2017, Filipos Vasilakis introduced a new way of developing web APIs: \emph{Introspected REST}. This came after the world had seen two other API styles arise very recently. Two years earlier, Facebook announced GraphQL and Google made gRPC available to the public. But in contrast two both of these, Introspected REST did not attract a lot of attention and still only leads a niche existence. Yet the question arises whether the industry misses out on something in ignoring Introspected REST. Could it be that Introspected REST really is an alternative to REST and GraphQL, as suggested by Vasilakis, or even a better way of doing things?

To get to the bottom of this question, Introspected REST needs to be tested and compared against the other approaches used by the web API community today. The goal of my thesis was to present a comparison of Introspected REST with REST, GraphQL, and gRPC regarding three comparison criteria: performance, evolvability, and usability. In this summary, I will focus primarily on whether Introspected REST can do better than REST\@.

In \cref{sec:introspected_rest}, the problems of REST as identified by Vasilakis are described. These problems motivated the creation of a new API style. After that, the two pillars of Introspected REST that help to avoid those problems, introspection and microtypes, are introduced. For each of the three comparison criteria, \cref{sec:comparison} contains an outline of the method and presents the results of the comparison. Finally, in \cref{sec:summary}, the results are shortly summarized and discussed.

\section{Introspected REST}\label{sec:introspected_rest}

In \autocite[sec.~8.2]{Vasilakis2017}, Vasilakis points out the problems he sees with REST, based on his own experience and without providing empirical evidence.

First, in a usual REST API, hypermedia information and other metadata are sent along with the plain data. Because the server does not know what information the client is actually interested in, it has to send all the metadata available, which can lead to huge response messages. Clients who do not make use of some or any of the metadata still have to handle the higher complexity that comes with these additional information. Moreover, it deteriorates the performance of the communication, because possibly unnecessary data is sent to the client and the (static) metadata cannot be cached independently of the plain data, although the former tend to change less frequently than the latter \autocite[secs.~8.2.1-8.2.4]{Vasilakis2017}.

Second, REST APIs use media types, which are mostly big monolithic structures with many responsibilities. In order to conform to the specification, clients and servers have to take an all-or-nothing approach when implementing a media type. Media types are also not composable, which, for example, makes it hard to switch out one part while keeping the other parts. When using REST, this would require a completely new media type specification \autocite[sec.~8.2.7.2]{Vasilakis2017}.

Third, REST makes it difficult to incrementally evolve an API that does not yet provide hypermedia elements to become a \enquote{Level 3} REST API \autocite{Richardson2008}. Because plain data and metadata are intertwined in a single response, such a change could break existing clients. And since media types lack composability, individual parts of a media type cannot evolve without needing to change the whole media type \autocites[secs.~8.2.5, 8.2.6.1]{Vasilakis2017}{Vasilakis2017a}.

With Introspected REST, Vasilakis wanted to create an API style that solves these problems while maintaining the benefits of REST \autocite[ch.~2]{Vasilakis2017} \textendash{} especially evolvability, which makes REST a good choice for public APIs that are supposed to be around for a long time \autocite[p.~41]{Block2014}. Introspected REST carries over most of the six REST constraints unchanged, but replaces \textit{Hypermedia as the engine of application state} with \textit{Introspection as the engine of application state}. Furthermore, Introspected REST encourages the use of \textit{microtypes}.

\subsection{The Introspection Principle}
The introspection principle states that a client should be able to examine the capabilities and properties of an API and its resources at runtime \autocite[sec.~9.3]{Vasilakis2017}. That is, in Introspected REST, clients can at any given moment request information like the schema of the expected response, next available actions, or the functionality the API provides for a specific resource. Similar to REST APIs \autocite{Fielding2008}, a client of an Introspected REST API only needs to know the initial URL and support the media- and microtypes used by the API.

An important characteristic of the introspection process is that it separates data from metadata \autocite[sec.~9.3.2]{Vasilakis2017}. Clients will only receive plain data with one request and have to issue another one in order to receive additional metadata.

What distinguishes the introspection principle from REST's hypermedia principle is, besides this separation, that clients can customize the introspection responses they receive through microtypes \autocite[sec.~9.3.1]{Vasilakis2017}. Microtypes make it possible for a client to precisely indicate which metadata it wants to receive.

\subsection{Microtypes}
The idea of microtypes is to break down media types into small, independent, composable units of functionality \autocite[sec.~9.2]{Vasilakis2017}. For example, one microtype could deal with pagination, another one with semantic information about the resources via RDF, and a third one with semantic information via JSON-LD\@.

The main advantage that microtypes offer to API clients is a more fine-grained content negotiation. Clients can choose exactly what data they want to receive from the server, therefore reducing the amount of unnecessary data sent. Furthermore, microtypes let choose clients from every possible combination of microtypes a server provides, satisfying the needs of lots of different clients \autocite[sec.~9.2.1.1]{Vasilakis2017}. An additional advantage is that microtypes enable the reuse of functionality across APIs \autocite[sec.~9.2.1.2]{Vasilakis2017} and could turn out to be a good platform for an ecosystem of patterns and building blocks of APIs.

\section{Comparison}\label{sec:comparison}

As described in \cref{sec:introduction}, the goal my thesis was to compare Introspected REST with REST, GraphQL, and gRPC\@. Therefore, comparison criteria had to be defined. Vasilakis writes about REST\@:

\begin{displaycquote}[][sec.~2]{Vasilakis2017}[.]
  It's inflexible, difficult to implement, difficult to test, with performance and implementation issues. But most importantly, any implementation of REST model is very complex
\end{displaycquote}

\noindent{}Introspected REST tries to solve the problems of REST like the impact on performance and complexity, while maintaining the benefits, especially the good evolvability. Therefore, for this comparison, the performance, evolvability, and complexity/usability of the four API styles were analysed, assuming a public API. One crucial property of public APIs is that they are used by a variety of clients \autocite[S.~7]{Jacobson2011} that are out of the provider's control. According to Mitra, the primary goal of a public API is to increase its market share, that is, to convince a lot of client developers to use the API \autocite[06:47--07:03]{Mitra2013}. Thus, the provider has to make the API great from the perspective of a client developer. For this reason, all comparison criteria were observed from this perspective.

\subsection{Performance}\label{subsec:performance}
The most important performance metric for a client developer is the \emph{response time}, which is the time from when the first byte of the request is sent to when the last byte of the response is received. To measure the response time for the API styles under examination, a scenario-based experiment was conducted. Every API client was instructed to execute five tasks using an API for digital note-taking. The five tasks are described in \cref{app:perf-tasks}. They typify interaction patterns between client and server that are commonly found in APIs, like a single request-response, fetching all items of a list (\textit{N+1} queries), or multi-deletion. For every task, the time the client needed to finish it was measured using \textit{Apache JMeter}\footnote{Apache JMeterâ„¢: \url{https://jmeter.apache.org/} (visited 14/02/2021)}.

Independent variables in this experiment were the latency, network throughput, and the performance of the client and server themselves. The experiment was carried out in a local environment and data transmission happened via the loopback network interface. This made it possible to control bandwidth and latency. The bandwidth was artificially limited to 34KB/s upload and 58KB/s download in a first, and 100KB/s up- and download in a second execution, while the latency was virtually zero. The downside of this setup was that client and server had to share hardware resources.

The API client was constructed using samplers of Apache JMeter. The servers were implemented based on ASP.NET Core, using third-party libraries for the REST, GraphQL, and gRPC APIs and a library for Introspected REST that was developed as part of the thesis. The latter was inspired by suggestions from Vasilakis \autocite[ch.~10]{Vasilakis2017}. The Introspected REST client requested only links and no additional metadata.

The figure in \cref{app:perf-results} plots the average response times per task for every API style relative to the response time for the Introspected REST API\@. GraphQL shows the best overall performance, followed by gRPC. The reason is, as I discuss in my thesis, that GraphQL sends the least data between client and server, while gRPC offers a performance-optimized protocol. The differences between Introspected REST and REST cannot necessarily be attributed to the API styles themselves, but are more a consequence of the library used to implement the REST API. I concluded that Introspected REST does not offer huge performance benefits compared to REST in this experiment. This result, however, should not be interpreted as if Introspected REST does not offer performance benefits at all. Especially when clients do not request additional metadata, using Introspected REST could lead to a significant performance improvement. But in this experiment, the clients for REST and Introspected REST both requested the same kind of data. Other limitations of the experiment include that requests were not sent in parallel and that all but the gRPC client used version 1.1 of the HTTP protocol.

\subsection{Evolvability}
Evolvability describes the ability of a system to adapt to a changing environment or changed requirements \autocite{Breivold2007}. When talking about APIs, evolvability refers to the degree to which an API can change without impacting existing clients \autocite[p.~34]{Fielding2000}. Changes to the API can be classified as either breaking or non-breaking. Breaking changes force a modification of the client in order to be able to successfully communicate with the server again \autocite[p.~215]{Lauret2019}.

To compare the evolvability of the four API styles, changes of the note-taking APIs mentioned in \cref{subsec:performance} were simulated. Then, for every API style, a change was either classified as breaking or non-breaking.

A description of the changes made to the API as well as the results can be found in \cref{app:evolvability-changes} and \cref{app:evolvability-results}, respectively. Introspected REST and REST both can be used to design APIs which are more evolvable than GraphQL or gRPC APIs. Especially through the use of hypermedia elements can clients incorporate changes, even changes in the business logic, without modification \autocite[37:35â€“-38:47]{Drotbohm2019}. Introspected REST achieves its goal of keeping REST's good evolvability and can even improve slightly on it through microtypes.

\subsection{Usability}
To compare the usability of the API styles, a heuristic evaluation \autocite{Nielsen1990} was performed. This usability inspection method was used despite problems, like incompleteness or lack of validity \autocites{Kock2009}{Law2004}, because of the time-limited nature of this thesis. The heuristics were compiled from common usability principles as well as studies of the usability of class library APIs. They are described in detail in my thesis, section 5.3.

\cref{app:usability-results} summarizes the results of the evaluation, using a scale from \texttt{-} (API style does not comply with heuristic at all) to \texttt{+++} (API style fully complies). Every API style shows individual strengths and weaknesses, obstructing any attempt to even order the API styles partially by their usability. The precise specification of GraphQL makes all GraphQL APIs look familiar. Furthermore, they are very predictable because client developers only get back the data they selected. Introspected REST offers a similar advantage through microtypes. When designed with this goal in mind, microtypes can make it possible for clients to specify exactly in which data they are interested. Other advantages of microtypes are that they make it easier to use common patterns in APIs, therefore increasing the consistency within and between APIs, and that their modularity enables code reuse for client developers.

\section{Summary}\label{sec:summary}

In this thesis, a first comparison of Introspected REST with the alternative API styles REST, GraphQL, and gRPC was presented. Introspected REST builds upon REST, but adds the introspection principle and microtypes to it. Thus, of special interest was whether Introspected REST can match or even surpass the qualities of REST\@. In the experiments and evaluations conducted, Introspection REST shows similar performance and evolvability to REST, but a better usability thanks to microtypes.

This thesis did not include an examination of an Introspected REST client that does not use additional metadata. Such a client is expected to show better performance and usability at the expense of evolvability.

Introspected REST seems to steer a pragmatic middle course between low complexity and high evolvability. Pragmatic, because in the real world, a lot of REST clients do not make any use of hypermedia, but are instead highly coupled to the server. Through the separation of plain data and metadata can these clients benefit from a better performance and lower complexity. Microtypes make it possible to satisfy the needs of many different clients, making it suitable for APIs that nowadays use GraphQL\@.